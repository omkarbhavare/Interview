Difference between primitive & non primitive
Primitive types in JavaScript, like Number, String, and Boolean, are simple, immutable, and stored directly in the stack. They are compared by value.
Non-primitive types, like Objects, Arrays, and Functions, are complex, mutable, and stored in the heap, with a reference in the stack. They are compared by reference.

var let const


üîç var ‚Äî the Old Way

- Function-scoped (not block-scoped)
- Hoisted and initialized as undefined
- Can be redeclared and updated
```
if (true) {
  var a = 5;
}
console.log(a); // ‚úÖ 5 (not block scoped!)
```

‚ùó Developer Warning:

- Variables declared with var can leak outside the block ‚Üí Causing unexpected behavior


üîç let ‚Äî Block Scoped Savior

- Block-scoped
- Hoisted but in a temporal dead zone (TDZ) ‚Äî accessing before declaration throws error
- Can be updated, not redeclared in the same scope

```
‚ö†Ô∏è TDZ in Action

function demoLet() {
  // console.log(y); ‚ùå ReferenceError: Cannot access 'y' before initialization
  let y = 20;
  console.log(y); // 20
}
demoLet();

üß± Block Scoping

if (true) {
  let blockVar = "scoped!";
  console.log(blockVar); // ‚úÖ scoped!
}
// console.log(blockVar); ‚ùå ReferenceError

‚õî Can't Redeclare
let msg = "Hello";
// let msg = "Hi again"; ‚ùå SyntaxError: Identifier 'msg' has already been declared
```



üîç const ‚Äî Immutable Binding

- Block-scoped
- Hoisted but in TDZ
- Cannot be updated or redeclared
- Object and array values can still be mutated
```
üìå Immutable Binding, Not Value

const PI = 3.14;
// PI = 3.14159; ‚ùå TypeError

const user = { name: "Omkar" };
user.name = "Bhavare"; // ‚úÖ Allowed: object properties can change

console.log(user); // { name: "Bhavare" }

‚õî Can't Redeclare or Reassign

const name = "Omkar";
// const name = "Bhavare"; ‚ùå SyntaxError
// name = "Bhau"; ‚ùå TypeError

‚ö†Ô∏è Has to be Declared & Initialized at the same time

const name ; ‚ùå 
const age = 24; ‚úÖ
```



Hoisting: Hoisting in JavaScript is when variable and function declarations are moved to the top of their scope before code execution. Only declarations are hoisted, not initializations, so accessing variables before initialization will result in undefined. Functions declared with function are fully hoisted, while let and const variables are hoisted but remain in a "temporal dead zone. Hoisting helps avoid errors by allowing functions or variables to be used before their declaration.

üîπ 1. Variable Declarations (var, let, const)

```
‚úÖ var ‚Äî Hoisted and Initialized with undefined

console.log(a); // ‚úÖ undefined
var a = 5;

‚ö†Ô∏è let and const ‚Äî Hoisted but Not Initialized (TDZ)

console.log(b); // ‚ùå ReferenceError: Cannot access 'b' before initialization
let b = 10;

console.log(c); // ‚ùå ReferenceError
const c = 20;

These are hoisted, but are in the Temporal Dead Zone (TDZ) ‚Äî the time between hoisting and actual initialization.
```


üîπ 2. Function Declarations ‚Äî Fully Hoisted

```
greet(); // ‚úÖ Hello Omkar!
console.log(greet); // ‚úÖ[Function: greet]

function greet() {
  console.log("Hello Omkar!");
}
```


üîπ 3. Function Expressions (var, let, const)

```
1Ô∏è‚É£ Var Function Expression
console.log(sayHi); // ‚úÖ undefined (only if declared with var)
sayHi();            // ‚ùå TypeError: sayHi is not a function

var sayHi = function () {
  console.log("Hi!");
};

2Ô∏è‚É£ let or const Function Expressions ‚Üí TDZ

sayHello(); // ‚ùå ReferenceError

let sayHello = function () {
  console.log("Hello!");
};

```


üîπ 4. Arrow Functions

Arrow functions behave exactly like function expressions, so:
- var ‚Üí hoisted as undefined
- let/const ‚Üí hoisted but in TDZ
```
console.log(arrowFn); // ‚úÖ undefined
arrowFn(); // ‚ùå TypeError : arrowFn is not a function

var arrowFn = () => {
  console.log("Arrow!");
};

console.log(newArrowFn); // ‚ùå ReferenceError: Cannot access 'newArrowFn' before initialization

let newArrowFn = () => {
  console.log("Arrow!");
};
```



üîπ 5. Class Declarations ‚Äî Hoisted, but In TDZ

```
const obj = new Person(); // ‚ùå ReferenceError

class Person {
  constructor() {
    console.log("I am a class");
  }
}

// Even though classes are hoisted, they‚Äôre also in the TDZ, like let and const.
```

Temporal Dead Zone: The Temporal Dead Zone (TDZ) refers to the period between the hoisting of a variable declared with let or const and its value initialization in the code. During this time, any reference to the variable will result in a ReferenceError, as it is in an uninitialized state. 
TDZ only applies to let and const, not var