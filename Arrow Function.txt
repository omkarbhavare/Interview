Arrow Function: Arrow functions are a shorter way to write functions in JavaScript.
 They donâ€™t have their own this, and instead inherit this from the surrounding (lexical) scope.
 They're great for callbacks, one-liners, and preserving context, especially in methods like map, filter, or event handlers.

```
// Basic one-liner
const add = (a, b) => a + b;
console.log(add(2, 3)); // 5

// With curly braces and return
const multiply = (a, b) => {
  return a * b;
};

// Single param (no need for parens)
const square = x => x * x;

// No params
const greet = () => console.log("Hello, Omkar!");

// Returning object (wrap in parentheses!)
const getUser = () => ({ name: "Omkar", age: 27 });
```


âœ… A. Lexical this --> Arrow functions do not bind their own this â†’ they inherit from the surrounding context


```
âŒ Problem with Traditional Function

function Timer() {
  this.seconds = 0;

  setInterval(function () {
    this.seconds++; // âŒ `this` is NOT the Timer instance
    console.log(this.seconds); // NaN or error
  }, 1000);
}
new Timer();


âœ… Arrow Function Solution

function Timer() {
  this.seconds = 0;

  setInterval(() => {
    this.seconds++; // âœ… Correct! Lexical `this` from Timer
    console.log(this.seconds);
  }, 1000);
}
new Timer();
```


âœ… B. Cleaner in Array Methods--> ðŸŽ¯ Arrow functions are ideal for functional programming: map, filter, reduce, sort, forEach

```
const numbers = [1, 2, 3];

// Traditional way
const doubled = numbers.map(function (num) {
  return num * 2;
});

// Arrow function way
const doubledArrow = numbers.map(num => num * 2);
```


ðŸ§ª Edge Cases & Gotchas


âŒ Arrow Functions Can't Be Used as Constructors

Arrow functions donâ€™t have their own this or prototype, so can't be used with new.

âŒ No arguments Object

```
const showArgs = () => {
  console.log(arguments); // âŒ ReferenceError
};
showArgs(1, 2, 3);

âœ… Use Rest Parameters Instead
const showArgs = (...args) => {
  console.log(args); // âœ… [1, 2, 3]
};
showArgs(1, 2, 3);
```